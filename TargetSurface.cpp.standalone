/////////////////////////////////////////////////////////////////
/*
 * $Id: TargetSurface.cpp.standalone,v 1.1 2007/10/17 13:16:55 sander Exp $
 *
 * $Log: TargetSurface.cpp.standalone,v $
 *
 * This new class contains the few methods of Surface that I really need.
 * When this package is compiled with -DPSURFACE_STANDALONE, it is used
 * as the target surface of the parametrization.  When compiled within
 * Amira, the standard Surface class is still used (the real one, no
 * local copy).  That way I can still watch target surfaces with the
 * normal SurfaceView module.
 * mailtoauthor: sander@zib.de
 *
 *
 */
/////////////////////////////////////////////////////////////////
#include <stdio.h>
#include <ctype.h>
#include <cstring>

#include "TargetSurface.h"


Surface::Patch& Surface::Patch::operator=(const Surface::Patch& other)
{
    innerRegion = other.innerRegion;
    outerRegion = other.outerRegion;
    boundaryId  = other.boundaryId;
    branchingPoints = other.branchingPoints;
    triangles = other.triangles;
    segments  = other.segments;
    return *this;
}

Surface::Patch::Patch(const Surface::Patch& other)
{ 
    *this = other;
}

#if defined HAVE_AMIRAMESH || !defined PSURFACE_STANDALONE
Surface::Surface(HxParamBundle* bundle)
{
    if (bundle) {
        params = bundle;
        hasOwnParamBundle=0;
    } else {
        params = new HxParamBundle;
        hasOwnParamBundle = 1;
    }
#else
Surface::Surface()
{
#endif
    lastTriangleIdx = -1;
    lastWhich = -1;
    lastGlobal = 0;
}

Surface::~Surface()
{
#if defined HAVE_AMIRAMESH || !defined PSURFACE_STANDALONE
    if (hasOwnParamBundle)
        delete params;
#endif

    for (int i=0; i<patches.size(); i++) {
        if (patches[i])
            delete patches[i];
    }
}

void Surface::clear()
{
    int i;
    points.resize(0);
    triangles.resize(0);

    for (i=0; i<patches.size(); i++)
        delete patches[i];
    patches.resize(0);
    
#if defined HAVE_AMIRAMESH || !defined PSURFACE_STANDALONE
    params->materials()->removeAll();
#endif
}

void Surface::removePoint(int patch,int point)
{
    std::vector<int> tris;
    int i;
    for (i=0 ; i<patches[patch]->triangles.size() ; i++) {
        Triangle& ta=triangles[patches[patch]->triangles[i]];
        if (point==ta.points[0] || point==ta.points[1] || point==ta.points[2])
            tris.push_back(i);
    }
    if (tris.size()==0) {
        printf("ERROR: Surface::removePoint(%d,%d), no triangle found\n",
               patch,point);
        return;
    }
    if (tris.size()==1) {
        patches[patch]->triangles.erase(patches[patch]->triangles.begin() + tris[0]);
        printf("WARNING: IMPLEMENT POINT TYPE SWITCH (inner->contour)\n");
        return;
    }
}

int Surface::getNeighbourTriangle(int triangleIdx, int which, int global)
{
    lastGlobal = global;
    lastTriangleIdx = lastWhich = -1;

    if (triangleIdx >= triangles.size() || which < 0 || which > 2)
        return -1;

    int ret = -1;
    Triangle tri = triangles[triangleIdx];
    if (tri.neighbours[which].isEmpty)
        return -1;

    ret = tri.neighbours[which].neighbourIdx;
       
    return ret;
}


void Surface::removeEmptyPatches()
{
    int nPatches = patches.size();
    int nTruePatches = 0;
    int i;
    for (i=0; i<nPatches; i++) {
        if (patches[i]->triangles.size() == 0) {
            patches[i]->triangles.resize(0);
            patches[i]->branchingPoints.resize(0);
            patches[i]->segments.resize(0);
        } else {
            patches[nTruePatches]=patches[i];
            nTruePatches++;
        }
    }    
    patches.resize(nTruePatches);

    for (i=0; i<nTruePatches; i++) {
        Patch* patch = patches[i];
        for (int k=patch->triangles.size()-1; k>=0; k--)
            triangles[patch->triangles[k]].patch = i;
    }
}

void Surface::recompute()
{
    removeEmptyPatches();
}

void Surface::cleanup()
{
    int i, n = edgesPerPoint.size();

    edgesPerPoint.resize(0);

    n = patches.size();
    for (i=0; i<n; i++)
        patches[i]->segments.resize(0);
}

void Surface::copyData(const Surface &source)
{
    int i, size;

    lastTriangleIdx = source.lastTriangleIdx;
    lastWhich = source.lastWhich;
    lastGlobal = source.lastGlobal;
    lastNeighbourIdx = source.lastNeighbourIdx;
    
#if defined HAVE_AMIRAMESH || !defined PSURFACE_STANDALONE
    params->operator=(*source.params);
#endif

    edgesPerPoint = source.edgesPerPoint;
    triangles = source.triangles;

    // Patches
    size = patches.size();
    for (i=0; i<size; i++)
        if (patches[i]) delete patches[i];

    size = source.patches.size();
    patches.resize(size);
    for (i=0; i<size; i++) {
        if (source.patches[i]) {
            patches[i] = new Patch();

            // I don't want to add a copy assignment operator to Patch..
            patches[i]->innerRegion = source.patches[i]->innerRegion;
            patches[i]->outerRegion = source.patches[i]->outerRegion;
            patches[i]->boundaryId = source.patches[i]->boundaryId;
            patches[i]->branchingPoints = source.patches[i]->branchingPoints;
            patches[i]->triangles = source.patches[i]->triangles;
            patches[i]->segments = source.patches[i]->segments;
        }
        else patches[i] = NULL;
    }

    // PointType and points
    points = source.points;
}

#if defined HAVE_AMIRAMESH || !defined PSURFACE_STANDALONE
int Surface::write(const char *file, int ascii)
{
    ascii = true;

    FILE *out=fopen(file,"wb");
    if (!out) {
        //theMsg->ioError(file);
        return(1);
    }
    fprintf(out,"# %s 0.1 %s\n\n","HyperSurface",ascii ? "ASCII" : "BINARY");
    
    int result = writeSurfaceData(out, ascii);

    fclose(out);

    return result;
}

int Surface::writeSurfaceData(FILE *out, int ascii)
{
    assert(ascii);  // only works for ascii == true
    int err=0,i;
//    fprintf(out, "Parameters ");
    params->print(out);
    fprintf(out, "\n");
        
    fprintf(out,"Vertices %d\n",points.size());
    for ( i=0 ; i<points.size() && !err; i++)
        fprintf(out,"\t%f %f %f\n",
                points[i][0], points[i][1], points[i][2]);

    fprintf(out,
            "NBranchingPoints %d\n"
            "NVerticesOnCurves %d\n"
            "BoundaryCurves %d\n",
            0,0,0);

    fprintf(out,"Patches %d\n",patches.size());
    HxParamBundle* materials = params->materials();
    // don't write obsolete triangles !!!
    for (i=0 ; i<patches.size() ; i++) {
        int nTriangles = 0;
        for (int j=0 ; j<patches[i]->triangles.size() ; j++) {
            int iTri = patches[i]->triangles[j];
            if (triangles[iTri].patch > -1)   // == i ?
                patches[i]->triangles[nTriangles++] = iTri;
        }
        patches[i]->triangles.resize(nTriangles);
    }
    
    for (i=0 ; i<patches.size() ; i++) {
        fprintf(out,"{\n");
        
        if (patches[i]->innerRegion >= 0) {
            HxParamBundle* inner = materials->bundle(patches[i]->innerRegion);
            if (inner) fprintf(out,"InnerRegion %s\n", inner->name());
        }
        
        if (patches[i]->outerRegion >= 0) {
            HxParamBundle* outer = materials->bundle(patches[i]->outerRegion);
            if (outer) fprintf(out,"OuterRegion %s\n", outer->name());
        }
        
        fprintf(out,
                "BoundaryID %d\n"
                "BranchingPoints %d\n    ",
                patches[i]->boundaryId,
                patches[i]->branchingPoints.size());
        
        for (int j=0 ; j<patches[i]->branchingPoints.size() ; j++) {
            fprintf(out,"  %d",patches[i]->branchingPoints[j]);
        }
        
        fprintf(out,"\nTriangles %d\n",patches[i]->triangles.size());

        for (int j=0 ; j<patches[i]->triangles.size() ; j++)
            fprintf(out,"  %d %d %d\n",
                    triangles[patches[i]->triangles[j]].points[0]+1,
                    triangles[patches[i]->triangles[j]].points[1]+1,
                    triangles[patches[i]->triangles[j]].points[2]+1);

        fprintf(out,"}\n");
    }
    return(0);
}
#endif

void Surface::getBoundingBox(float bbox[6]) const
{
    if (points.size()) {
        bbox[0] = bbox[1] = points[0][0];
        bbox[2] = bbox[3] = points[0][1];
        bbox[4] = bbox[5] = points[0][2];
    } else {
        std::memset(bbox,0,6*sizeof(float));
    }

    for (int i=0 ; i<points.size() ; i++) {
        for (int k=0 ; k<3 ; k++) {
            if (bbox[k*2]>points[i][k])
                bbox[k*2]=points[i][k];
            if (bbox[k*2+1]<points[i][k])
                bbox[k*2+1]=points[i][k];
        }
    }
}


int Surface::removeUnusedPoints()
{
    int i,k;
    int nPoints = points.size();
    int nTriangles = triangles.size();

    std::vector<int> newIndex(nPoints);
    newIndex.assign(newIndex.size(), -1);

    for (i=0; i<nTriangles; i++) {
        Triangle& tri = triangles[i];
        if (tri.patch<0)
            continue;

        newIndex[tri.points[0]] = 1;
        newIndex[tri.points[1]] = 1;
        newIndex[tri.points[2]] = 1;
    }

    for (i=k=0; i<nPoints; i++) {
        if (newIndex[i]==1) {
            newIndex[i] = k;
            points[k] = points[i];
            k++;
        }
    }

    if (nPoints==k)
        return 0; // No unused points found

    for (i=0; i<nTriangles; i++) {
        Triangle& tri = triangles[i];
        if (tri.patch<0)
            continue;

        tri.points[0] = newIndex[tri.points[0]];
        tri.points[1] = newIndex[tri.points[1]];
        tri.points[2] = newIndex[tri.points[2]];
    }

    points.resize(k);
    edgesPerPoint.resize(0);
    trianglesPerPoint.resize(0);

    return nPoints-k;
}


void Surface::computeTrianglesPerPoint()
{
    int nPoints = points.size();
    int nTriangles = triangles.size();

    trianglesPerPoint.resize(nPoints);

    // This is a critical MEMORY LEAK:
    // memset(&trianglesPerPoint[0], 0, sizeof(trianglesPerPoint[0])*nPoints);
    
    // Need to resize the std::vectors individually (Detlev 10 Jan 2003).
    // resize(0) frees any dynamically allocated memory.
    for (int k=0; k<nPoints; k++)
        trianglesPerPoint[k].resize(0);
    
    for (int i=0; i<nTriangles; i++) {
        Surface::Triangle& tri = triangles[i];
        trianglesPerPoint[tri.points[0]].push_back(i);
        trianglesPerPoint[tri.points[1]].push_back(i);
        trianglesPerPoint[tri.points[2]].push_back(i);
    }
}
