/////////////////////////////////////////////////////////////////
/*
 * $Id: TargetSurface.cpp.standalone,v 1.1 2007/10/17 13:16:55 sander Exp $
 *
 * $Log: TargetSurface.cpp.standalone,v $
 *
 * This new class contains the few methods of Surface that I really need.
 * When this package is compiled with -DPSURFACE_STANDALONE, it is used
 * as the target surface of the parametrization.  When compiled within
 * Amira, the standard Surface class is still used (the real one, no
 * local copy).  That way I can still watch target surfaces with the
 * normal SurfaceView module.
 * mailtoauthor: sander@zib.de
 *
 *
 */
/////////////////////////////////////////////////////////////////
#include <stdio.h>
#include <ctype.h>

#include "TargetSurface.h"

#if defined HAVE_AMIRAMESH || !defined PSURFACE_STANDALONE
int Surface::write(const char *file, int ascii)
{
    ascii = true;

    FILE *out=fopen(file,"wb");
    if (!out) {
        return(1);
    }
    fprintf(out,"# %s 0.1 %s\n\n","HyperSurface",ascii ? "ASCII" : "BINARY");
    
    int result = writeSurfaceData(out, ascii);

    fclose(out);

    return result;
}

int Surface::writeSurfaceData(FILE *out, int ascii)
{
    assert(ascii);  // only works for ascii == true
    int err=0,i;

    fprintf(out, "\n");
        
    fprintf(out,"Vertices %d\n",points.size());
    for ( i=0 ; i<points.size() && !err; i++)
        fprintf(out,"\t%f %f %f\n",
                points[i][0], points[i][1], points[i][2]);

    fprintf(out,
            "NBranchingPoints %d\n"
            "NVerticesOnCurves %d\n"
            "BoundaryCurves %d\n",
            0,0,0);

    fprintf(out,"Patches %d\n",1);   // 1 dummy patch

    // //////////////////////////
    //   Write one dummy patch
    // //////////////////////////
    fprintf(out,"{\n");
    
    fprintf(out,
            "BoundaryID %d\n"
            "BranchingPoints %d\n    ",
            0,
            0);
    
    fprintf(out,"\nTriangles %d\n",triangles.size());
    
    for (int j=0 ; j<triangles.size() ; j++)
        fprintf(out,"  %d %d %d\n",
                triangles[j].points[0]+1,
                triangles[j].points[1]+1,
                triangles[j].points[2]+1);
    
    fprintf(out,"}\n");

    return(0);
}
#endif

void Surface::getBoundingBox(float bbox[6]) const
{
    if (points.size()) {
        bbox[0] = bbox[1] = points[0][0];
        bbox[2] = bbox[3] = points[0][1];
        bbox[4] = bbox[5] = points[0][2];
    } else {
        for (int i=0; i<6; i++)
            bbox[i] = 0;
    }

    for (int i=0 ; i<points.size() ; i++) {
        for (int k=0 ; k<3 ; k++) {
            if (bbox[k*2]>points[i][k])
                bbox[k*2]=points[i][k];
            if (bbox[k*2+1]<points[i][k])
                bbox[k*2+1]=points[i][k];
        }
    }
}


int Surface::removeUnusedPoints()
{
    int i,k;
    int nPoints = points.size();
    int nTriangles = triangles.size();

    std::vector<int> newIndex(nPoints);
    newIndex.assign(newIndex.size(), -1);

    for (i=0; i<nTriangles; i++) {
        Triangle& tri = triangles[i];

        newIndex[tri.points[0]] = 1;
        newIndex[tri.points[1]] = 1;
        newIndex[tri.points[2]] = 1;
    }

    for (i=k=0; i<nPoints; i++) {
        if (newIndex[i]==1) {
            newIndex[i] = k;
            points[k] = points[i];
            k++;
        }
    }

    if (nPoints==k)
        return 0; // No unused points found

    for (i=0; i<nTriangles; i++) {
        Triangle& tri = triangles[i];

        tri.points[0] = newIndex[tri.points[0]];
        tri.points[1] = newIndex[tri.points[1]];
        tri.points[2] = newIndex[tri.points[2]];
    }

    points.resize(k);
    trianglesPerPoint.resize(0);

    return nPoints-k;
}


void Surface::computeTrianglesPerPoint()
{
    int nPoints = points.size();
    int nTriangles = triangles.size();

    trianglesPerPoint.resize(nPoints);

    for (int k=0; k<nPoints; k++)
        trianglesPerPoint[k].resize(0);
    
    for (int i=0; i<nTriangles; i++) {
        Surface::Triangle& tri = triangles[i];
        trianglesPerPoint[tri.points[0]].push_back(i);
        trianglesPerPoint[tri.points[1]].push_back(i);
        trianglesPerPoint[tri.points[2]].push_back(i);
    }
}
