/////////////////////////////////////////////////////////////////
/*
 * $Id: TargetSurface.h.standalone,v 1.1 2007/10/17 13:16:55 sander Exp $
 *
 * $Log: TargetSurface.h.standalone,v $
 *
 * This new class contains the few methods of Surface that I really need.
 * When this package is compiled with -DPSURFACE_STANDALONE, it is used
 * as the target surface of the parametrization.  When compiled within
 * Amira, the standard Surface class is still used (the real one, no
 * local copy).  That way I can still watch target surfaces with the
 * normal SurfaceView module.
 * mailtoauthor: sander@zib.de
 *
 */
/////////////////////////////////////////////////////////////////
#ifndef SURFACE_H
#define SURFACE_H

#include <stdio.h>

#include <vector>
#include <psurface/StaticVector.h>

#if defined HAVE_AMIRAMESH || !defined PSURFACE_STANDALONE
#include <amiramesh/HxParamBundle.h>
#endif

/** This class implements structured, triangulated surfaces. A surface
    consists of a number of sub-surfaces, called @c patches. Each patch can
    have different regions on its two sides: @c innerRegion and
    @c outerRegion. Patches are bounded by @c contours.
    
    Points can have different @c pointTypes. Points not lying on a contour
    are @c INNER points. Points lying on more than one contour, or being the
    first or last point of a contour are @c BRANCHING points. All other
    points are @c CONTOUR points.
    
    This implementation works with indices instead of pointers, this allows
    easy realloc. The surface contains one big array of @c points, of
    @c triangles, of @c patches, of @c contours and for temporary use of
    @c edges and lists of @c edgesPerPoint for each point. */

class Surface { 

  public:

    // ==================== Subclass declaration ====================

    /**@name Subclass declaration */ //@{
    
    /// This class represents a surface triangle.
    class Triangle {
      public:
        /** Indices of the three points of the triangle. <b> Note:</b> In the
            file format, the first point in the surface's point array is 1.
            In this data structure, the first point has the index 0.
            Conversion is done when writing and reading. */
        int points[3];

        /// Index of the patch this triangle belongs to.
        int patch;

        /// This struct is used to store neighbourhood information.
        struct Neighbour {
            /// Set if there is no neighbouring triangle in the same patch.
            unsigned int isEmpty:1;

            /// Set if the triangle touches a contour.
            unsigned int isContour:1;

            /// Index of neighbouring triangle, or index of boundary edge.
            int neighbourIdx:30;

            /// Constructor.
            Neighbour() { isEmpty=1; isContour=0; neighbourIdx=0; }
        };

        /// One neighbour struct for each of the three triangle edges.
        Neighbour neighbours[3];
        
        inline void invert() {
            int p = points[1];
            points[1] = points[2];
            points[2] = p;
            Neighbour n = neighbours[1];
            neighbours[1] = neighbours[2];
            neighbours[2] = n;
        }

        inline int hasPoint(int p) {
            return (p==points[0] || p==points[1] || p==points[2]);
        }

        inline int pointIndex(int p) {
            if (p==points[0]) return 0;
            if (p==points[1]) return 1;
            if (p==points[2]) return 2;
            return -1;
        }
    };
    
    /// This class represents a patch of connected triangles.
    class Patch {
      public:
        /// Index of the inner region (starting from zero).
        int innerRegion;

        /// Index of the outer region (starting from zero).
        int outerRegion;

        /// Additional id which defines some kind of material properties.
        int boundaryId;

        /// Indices of all inner branching points.
        std::vector<int> branchingPoints;

        /// Indices of all the triangles of the patch.
        std::vector<int> triangles;

        /// Stores information about segments, i.e. subsequent contours
        struct Segment {
            /// Index of the first contour of a segment.
            int first;

            /// Index of the last contour (for closed segments first==last).
            int last;
        };
        
        /// Contains all connected contour segments of the patch.
        std::vector<Segment> segments;

        /// Assignment operator
        Patch& operator=(const Patch& other);
        
        /// Default constructor.
        Patch() { innerRegion=outerRegion=boundaryId=0; }
        
        /// Copy constructor.
        Patch(const Patch& other);
    };

    //@}

    // ======================= Member variables =====================

    /**@name Member variables */ //@{

    /// Array of all surface points (required).
    std::vector<StaticVector<float,3> > points;

    /// Array of all surface patches (at least 1 patch is required).
    std::vector<Patch*> patches;

    /// Array of all surface triangles (required).
    std::vector<Triangle> triangles;       

    /// Stores for each point all edges incident at that point (temporary).
    std::vector< std::vector<int> > edgesPerPoint;

    ///Stores the edge ids for each triangle (optional and temporary).
    std::vector< std::vector<int> > edgesPerTriangle;
  
    /** Stores for each point all incident triangles. To initialize this
        array the method @c computeTrianglesPerPoint() has to be called
        explicitely. The class @c HxSurfaceEditor uses this information. */
    std::vector< std::vector<int> > trianglesPerPoint;

#if defined HAVE_AMIRAMESH || !defined PSURFACE_STANDALONE
    /** Contains info about the regions. The indices @c innerRegion and
        @c outerRegion refer to this structure, e.g. @c materials[0]. */
    HxParamBundle* params;
#endif

    //@}

    // ======================== Member methods ======================

    /**@name Member methods */ //@{

    /// Constructor. If params is null an own parameter bundle is created.
    Surface(
#if defined HAVE_AMIRAMESH || !defined PSURFACE_STANDALONE
            HxParamBundle* params=0
#endif
           );

    /// Destructor.
    ~Surface();

    /// Deletes all points, triangles, patches, materials, etc.
    virtual void clear();

    /** This method recomputes the connectivity information of a surface.
        Surface contours and point types are inewly determined. Patches
        containing disconnected triangles are separated into new patches. */
    void recompute();

    /// Removes patches containing no triangles.
    void removeEmptyPatches();

    /// Remove all triangles with patchid<0, returns number of removed tris.
    int removeObsoleteTriangles();

    /// Removes all points not referenced by any triangle.
    int removeUnusedPoints();

    /** Discards the contour information. This method should be called after
        the surface topology has been changed. */
    void cleanup();

    /// Returns bounding box of point coordinates.
    void getBoundingBox(float box[6]) const;

#if defined HAVE_AMIRAMESH || !defined PSURFACE_STANDALONE
    /// Write surface + header to a file.
    int write(const char *file, int ascii=0);

    /// Write the surface without header to file.
    int writeSurfaceData(FILE *out, int ascii=0);
#endif

    //@}

    // ====================== Internal methods ======================

    /**@name Internal methods */ //@{

    /** Initializes the array @c trianglePerPoint. */
    void computeTrianglesPerPoint();

    /** Fills the neighbour array for  all triangles without 
	decomposing patches. */
    void createNeighbours();
    
    ///
    void removePoint(int patch,int point);

    /** Remove triangles containing the same three points. 
        @return Number of removed triangles. */
    int removeDuplicateTriangles();
    
    /** Remove triangles with two or three identical points. 
        @return Number of removed triangles. */
    int removeDegenerateTriangles();

    ///
    int getEdgeOfTriangle(int triangleIdx,int which);

    ///
    int getNeighbourTriangle(int triangleIdx, int which, int global = 0);

    ///
    int getNextNeighbourTriangle();
        
    /// Copies the whole data set
    void copyData(const Surface &source);

    /// Appends a triangle and inserts it in given patch.
    void appendTriangle(int patchIdx, Triangle& triangle) {
        triangles.push_back(triangle);
        patches[patchIdx]->triangles.push_back(triangles.size()-1);
        triangle.patch = patchIdx;
    }

    // basic surface properties

    /// Make one patch.
    void makeOnePatch();

    /// Compute index of edge between given vertices
    int getEdgeIdx(int v1, int v2);

    /// Compute index of triangle with given vertices.
    int getTriangleIdx(int v1, int v2, int v3);

    /// Compute neighboured nodes around given node.


    //@}

  private:
    int lastTriangleIdx;
    int lastWhich;
    int lastGlobal;
    int lastNeighbourIdx;
    unsigned int hasOwnParamBundle;
};

#endif

