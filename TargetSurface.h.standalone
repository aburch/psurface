/////////////////////////////////////////////////////////////////
/*
 * $Id: TargetSurface.h.standalone,v 1.1 2007/10/17 13:16:55 sander Exp $
 *
 * $Log: TargetSurface.h.standalone,v $
 *
 * This new class contains the few methods of Surface that I really need.
 * When this package is compiled with -DPSURFACE_STANDALONE, it is used
 * as the target surface of the parametrization.  When compiled within
 * Amira, the standard Surface class is still used (the real one, no
 * local copy).  That way I can still watch target surfaces with the
 * normal SurfaceView module.
 * mailtoauthor: sander@zib.de
 *
 */
/////////////////////////////////////////////////////////////////
#ifndef TARGET_SURFACE_H
#define TARGET_SURFACE_H

#include <stdio.h>

#include <vector>
#include <psurface/StaticVector.h>

#if defined HAVE_AMIRAMESH || !defined PSURFACE_STANDALONE
#include <amiramesh/HxParamBundle.h>
#endif

/** This class implements structured, triangulated surfaces. A surface
    consists of a number of sub-surfaces, called @c patches. Each patch can
    have different regions on its two sides: @c innerRegion and
    @c outerRegion. Patches are bounded by @c contours.
    
    Points can have different @c pointTypes. Points not lying on a contour
    are @c INNER points. Points lying on more than one contour, or being the
    first or last point of a contour are @c BRANCHING points. All other
    points are @c CONTOUR points.
    
    This implementation works with indices instead of pointers, this allows
    easy realloc. The surface contains one big array of @c points, of
    @c triangles, of @c patches, of @c contours and for temporary use of
    @c edges and lists of @c edgesPerPoint for each point. */

class Surface { 

  public:

    // ==================== Subclass declaration ====================

    /**@name Subclass declaration */ //@{
    
    /// This class represents a surface triangle.
    class Triangle {
      public:
        /** Indices of the three points of the triangle. <b> Note:</b> In the
            file format, the first point in the surface's point array is 1.
            In this data structure, the first point has the index 0.
            Conversion is done when writing and reading. */
        std::tr1::array<int,3> points;

        /// This struct is used to store neighbourhood information.
        struct Neighbour {
            /// Set if there is no neighbouring triangle in the same patch.
            unsigned int isEmpty:1;

            /// Set if the triangle touches a contour.
            unsigned int isContour:1;

            /// Index of neighbouring triangle, or index of boundary edge.
            int neighbourIdx:30;

            /// Constructor.
            Neighbour() { isEmpty=1; isContour=0; neighbourIdx=0; }
        };

        /// One neighbour struct for each of the three triangle edges.
        Neighbour neighbours[3];
        
    };
    
    //@}

    // ======================= Member variables =====================

    /**@name Member variables */ //@{

    /// Array of all surface points (required).
    std::vector<StaticVector<float,3> > points;

    /// Array of all surface triangles (required).
    std::vector<Triangle> triangles;       

    /// Stores for each point all edges incident at that point (temporary).
    std::vector< std::vector<int> > edgesPerPoint;

    ///Stores the edge ids for each triangle (optional and temporary).
    std::vector< std::vector<int> > edgesPerTriangle;
  
    /** Stores for each point all incident triangles. To initialize this
        array the method @c computeTrianglesPerPoint() has to be called
        explicitely. The class @c HxSurfaceEditor uses this information. */
    std::vector< std::vector<int> > trianglesPerPoint;

#if defined HAVE_AMIRAMESH || !defined PSURFACE_STANDALONE
    /** Contains info about the regions. The indices @c innerRegion and
        @c outerRegion refer to this structure, e.g. @c materials[0]. */
    HxParamBundle* params;
#endif

    //@}

    // ======================== Member methods ======================

    /**@name Member methods */ //@{

    /// Constructor. If params is null an own parameter bundle is created.
    Surface(
#if defined HAVE_AMIRAMESH || !defined PSURFACE_STANDALONE
            HxParamBundle* params=0
#endif
           );

    /// Destructor.
    ~Surface();

    /// Deletes all points, triangles, patches, materials, etc.
    virtual void clear();

    /// Removes all points not referenced by any triangle.
    int removeUnusedPoints();

    /** Discards the contour information. This method should be called after
        the surface topology has been changed. */
    void cleanup();

    /// Returns bounding box of point coordinates.
    void getBoundingBox(float box[6]) const;

#if defined HAVE_AMIRAMESH || !defined PSURFACE_STANDALONE
    /// Write surface + header to a file.
    int write(const char *file, int ascii=0);

    /// Write the surface without header to file.
    int writeSurfaceData(FILE *out, int ascii=0);
#endif

    //@}

    // ====================== Internal methods ======================

    /**@name Internal methods */ //@{

    /** Initializes the array @c trianglePerPoint. */
    void computeTrianglesPerPoint();

    ///
    int getEdgeOfTriangle(int triangleIdx,int which);

    ///
    int getNeighbourTriangle(int triangleIdx, int which, int global = 0);

    ///
    int getNextNeighbourTriangle();
        
    /// Copies the whole data set
    void copyData(const Surface &source);

    /// Appends a triangle and inserts it in given patch.
    void appendTriangle(int patchIdx, Triangle& triangle) {
        triangles.push_back(triangle);
    }

    // basic surface properties

    /// Compute index of edge between given vertices
    int getEdgeIdx(int v1, int v2);

    /// Compute index of triangle with given vertices.
    int getTriangleIdx(int v1, int v2, int v3);

    /// Compute neighboured nodes around given node.


    //@}

  private:
    int lastTriangleIdx;
    int lastWhich;
    int lastGlobal;
    int lastNeighbourIdx;
    unsigned int hasOwnParamBundle;
};

#endif

